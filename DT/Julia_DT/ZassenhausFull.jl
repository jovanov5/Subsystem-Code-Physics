""" ZassenhausFull
    This file contains functions that perform a complete implementation of the Zassenhaus algorithm using QuantumClifford (i.e. extracting the intersection of two stabilizer
    groups via their F2 matrix representation).

    It additionally contains more specialized functions using the algorithm to investigate correlations between lattice points, and improved visualization.
"""

function extract_intersection(state::MixedDestabilizer, nbits::Int)
    """
        Helper function used in Zassenhaus, to extract from a 'quadrupled' state generated by stabilizers of the form e e q q, the state generated by q
    state       : quadrupled state obtained by Zassenhaus algorithm
    nbits       : number of qubits of the original system
    """

    # assert that we have a quadrupled system
    @assert(nqubits(state) == 4 * nbits)

    # extract the matrix describing the stabilizers
    bool_matrix = stab_to_gf2(stabilizerview(state))

    # account for the case of empty intersection
    if bool_matrix == zeros(Bool, 0, 8 * nbits)
            return maximally_mixed_state(nbits)
    # else: 'cut out' the correct quarter of the system
    else
            phases = zeros(UInt8, size(bool_matrix)[1])
            X_matrix = bool_matrix[:, 2*nbits+1:3*nbits]
            Z_matrix = bool_matrix[:, 6*nbits+1:7*nbits]

            state = Stabilizer(phases, X_matrix, Z_matrix)
            state = MixedDestabilizer(state)

            return state
    end
end

function zassenhaus_intersect(deformator, probe_state, nbits::Int)
    """ 
        This function uses the Zassenhaus algorihtm to obtain the intersection between a state stabilizer group and the deformator group, which is in turn generated by 
        Toric Code stabilizers and logicals.
    deformator      : list of deformator operators (TC stabilizers and logicals)
    probe_state     : list of state stabilizers
    nbits           : number of qubits of the probed system
    """
    
    # Generate 'Zassenhaus state' on quadrupled system
    state = maximally_mixed_state(4*nbits)

    for g in deformator
        project!(state, zassenhaus_map_f(g), keep_result=false)
    end

    for g in probe_state
        project!(state, zassenhaus_map_h(g), keep_result=false)
    end

    # trace out half the system, this effectively performs the canonicalization and 'reading out' of relevant stabilizers
    traceout!(state, 1:2*nbits)

    # traceout! doesn't reduce the system size, so here it still yields a 'qadrupled' state, from which we extract the state on the original system
    intersect = extract_intersection(state, nbits)

    return intersect
end

function zassenhaus_intersect(charge_representative, deformator, probe_state, nbits::Int)
    """ 
        Version of the above, but instead of considering the 'deformator group' we consider the 'particle string group' of all strings for a given particle type and a given
        pair of points, which is generated by a representative string and all the deformators (TC stabilizers and logicals)
    charge_representative   : bosonic or fermionic string operator connecting two points of interest
    deformator              : list of deformator operators (TC stabilizers and logicals)
    probe_state             : list of state stabilizers
    nbits                   : number of qubits of the probed system
    """
    
    # Generate 'Zassenhaus state' on quadrupled system
    state = maximally_mixed_state(4*nbits)

    project!(state, zassenhaus_map_f(charge_representative), keep_result=false)
    
    for g in deformator
        project!(state, zassenhaus_map_f(g), keep_result=false)
    end

    for g in probe_state
        project!(state, zassenhaus_map_h(g), keep_result=false)
    end

    # trace out half the system, this effectively performs the canonicalization and 'reading out' of relevant stabilizers
    traceout!(state, 1:2*nbits)

    # traceout! doesn't reduce the system size, so here it still yields a 'qadrupled' state, from which we extract the state on the original system
    intersect = extract_intersection(state, nbits)

    return intersect
end

function weight(pauli::PauliOperator)
    """
        Helper function computing the weight/support of a Pauli string, which is the number of qubits on which it does not act as the identity.
    pauli           : Pauli string operator
    """
    
    # sum the number of (X or Z) operators acting on each site. Gives 1 for X or Z, 2 for Y, and 0 for the identity
    support_vector = sum(cat(xbit(pauli), zbit(pauli), dims=2), dims=2)

    # then count non-zero elements to get the weight
    weight = count(i->(i>0), support_vector)

    return weight
end

function condensation_strings_full(r_2::Tuple{Int, Int}, state::MixedDestabilizer, system::EdgeSquareLattice, repfunction::Function, deformator)
    """
        Function that gives a list of operators connecting particles of a specified type between the point r_2 to the origin. Returns an empty list if r_2 and the origin are
        not correlated. 
    r_2             : lattice site. We consider correlation between this site and the origin.
    state           : stabilizer state for which we want to compute correlations
    system          : system on which this state lives (e.g. toric code on square lattice)
    repfunction     : function which gives a representative string of the correct particle type between the origin an r_2
    deformator      : list of string deforming operators (TC stabilizers and logicals)
    """
    
    nbits = system.nbits
    r_x = r_2[1]
    r_y = r_2[2]

    # obtain a bosonic/fermionic string from the origin to the point r_2
    rep_string = repfunction((r_x, r_y), system)
    
    # obtain the intersections between the state stabilizer group and the deformator group. There are two intersections for two deformator groups, one with and one without the rep_string
    trivial_intersect = zassenhaus_intersect(deformator, stabilizerview(state), nbits)
    string_intersect = zassenhaus_intersect(rep_string, deformator, stabilizerview(state), nbits)

    condensation_strings = []

    # If the origin and r_2 are correlated, that means the 'string_intersect' is larger than the 'trivial_intersect'.
    if size(stabilizerview(string_intersect))[1] > size(stabilizerview(trivial_intersect))[1]
        
        # loop over string_intersect stabilizers to see which of them would increase the size of the trivial_intersect group. These must be condensation strings
        for stab in stabilizerview(string_intersect)
            test_state = copy(trivial_intersect)
            project!(test_state, stab, keep_result=false)

            if size(stabilizerview(test_state))[1] > size(stabilizerview(trivial_intersect))[1]
                push!(condensation_strings, stab)
            end
        end
    end 
    
    # note: we return an empty list if points are not correlated
    return condensation_strings
end

function condensation_string_short(r_2::Tuple{Int, Int}, state::MixedDestabilizer, system::EdgeSquareLattice, repfunction::Function, deformator)
"""
        A simple extension of condensation_strings_full. If two points are correlated, this function uses condensation_strings_full to obtain a list of stabilizers connecting
        the two points, and then picks out one with the smallest weight. Returns false if the points are not correlated.
    r_2             : lattice site. We consider correlation between this site and the origin.
    state           : stabilizer state for which we want to compute correlations
    system          : system on which this state lives (e.g. toric code on square lattice)
    repfunction     : function which gives a representative string of the correct particle type between the origin an r_2
    deformator      : list of string deforming operators (TC stabilizers and logicals)
    """

    # uses above function to get list of condensation string operators between the two points
    condensation_strings = condensation_strings_full(r_2, state, system, repfunction, deformator)

    # if the points are not correlated, the list is empty
    if condensation_strings == []
        return false
    # else, loop and pick out the one with the smallest weight
    else
        short_string = condensation_strings[1]
        for string in condensation_strings
            if weight(string) < weight(short_string)
                short_string = string
            end
        end
    end

    return short_string
end

function visualise_the_stabiliser_dual(stabiliser::PauliOperator, system::EdgeSquareLattice)
    """
        Visualisation function that plots Z operators as red 'real lattice' strings and X operators as blue, dotted dual lattice strings.
    stabiliser      : stabilizer to be plotted
    system          : system on which the stabilizer lives (e.g. toric code on square lattice)
    """
    # stabilizer as matrix
    stab = stab_to_gf2(stabiliser)
    # plot the 'system background'
    L = system.L
    p = plot()
    nbits = system.nbits
    plot!([(-.5, -.5), (-1/2, L-0.5), (L-.5, L-.5), (L-.5, -.5), (-.5, -.5)], color=:black)


    for i in 0:L-1
        for j in 0:L-1
            # Horizontal X (dual) lines
            if stab[edge_picker(i, j, 0)] == 1
                plot!([(i-0.5, j+0.5), (i+0.5, j+0.5)], color=:blue, linewidth=4, linestyle=:dot)
            end
            # Vertical X (dual) lines
            if stab[edge_picker(i, j, 1)] == 1
                plot!([(i+0.5, j-0.5), (i+0.5, j+0.5)], color=:blue, linewidth=4, linestyle=:dot)
            end
            # Horizontal Z lines
            if stab[edge_picker(i, j, 1)+nbits] == 1
                plot!([(i, j), (i+0.5, j)], color=:red, linewidth=4)
                plot!([((i+1)%L - 0.5, j), ((i+1)%L, j)], color=:red, linewidth=4)
            end
            
            # Vertical Z lines
            if stab[edge_picker(i, j, 0)+nbits] == 1
                plot!([(i, j), (i, j+0.5)], color=:red, linewidth=4)
                plot!([(i, (j+1)%L - 0.5), (i, (j+1)%L)], color=:red, linewidth=4)
            end
        end
    end

    # Plot and display
    plot!(legend= false, xticks= 0:1:L, yticks= 0:1:L)
    xlims!(-1, L+1)
    ylims!(-1, L+1)
    display(p)
end

function visualise_the_stabiliser_dual(stabiliser::PauliOperator, system::EdgeSquareLattice, sites)
    """
        Visualisation function that plots Z operators as red 'real lattice' strings and X operators as blue, dotted dual lattice strings.
    stabiliser      : stabilizer to be plotted
    system          : system on which the stabilizer lives (e.g. toric code on square lattice)
    """
    # stabilizer as matrix
    stab = stab_to_gf2(stabiliser)
    # plot the 'system background'
    L = system.L
    p = plot()
    nbits = system.nbits
    plot!([(-.5, -.5), (-1/2, L-0.5), (L-.5, L-.5), (L-.5, -.5), (-.5, -.5)], color=:black)


    for i in 0:L-1
        for j in 0:L-1
            # Horizontal X (dual) lines
            if stab[edge_picker(i, j, 0)] == 1
                plot!([(i-0.5, j+0.5), (i+0.5, j+0.5)], color=:blue, linewidth=4, linestyle=:dot)
            end
            # Vertical X (dual) lines
            if stab[edge_picker(i, j, 1)] == 1
                plot!([(i+0.5, j-0.5), (i+0.5, j+0.5)], color=:blue, linewidth=4, linestyle=:dot)
            end
            # Horizontal Z lines
            if stab[edge_picker(i, j, 1)+nbits] == 1
                plot!([(i, j), (i+0.5, j)], color=:red, linewidth=4)
                plot!([((i+1)%L - 0.5, j), ((i+1)%L, j)], color=:red, linewidth=4)
            end
            
            # Vertical Z lines
            if stab[edge_picker(i, j, 0)+nbits] == 1
                plot!([(i, j), (i, j+0.5)], color=:red, linewidth=4)
                plot!([(i, (j+1)%L - 0.5), (i, (j+1)%L)], color=:red, linewidth=4)
            end
        end
    end

    for site in sites
        r_i = site[1]
        r_j = site[2]
        scatter!([(r_i, r_j)], color=:black, markersize=6)
        scatter!([(r_i + 0.5, r_j + 0.5)], color=:black, markersize=6)
        plot!([(r_i, r_j), (r_i+0.5, r_j+0.5)], color=:black, linewidth=2, linestyle=:dash)
    end

    # Plot and display
    plot!(legend= false, xticks= 0:1:L, yticks= 0:1:L)
    xlims!(-1, L+1)
    ylims!(-1, L+1)
    display(p)
end